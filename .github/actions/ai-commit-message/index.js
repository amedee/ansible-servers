import * as core from "@actions/core";
import fetch from "node-fetch";

const MODELS = [
  "mistralai/devstral-small-2505:free", // primary
  "openai/gpt-oss-20b:free", // fallback 1
  "moonshotai/kimi-dev-72b:free", // fallback 2
  // Add more fallback models here if you want
];

const URL = "https://openrouter.ai/api/v1/chat/completions";

const HTTP_TOO_MANY_REQUESTS = 429;
const HTTP_SERVICE_UNAVAILABLE = 503;

const INSTRUCTIONS = `
The commit message must start with a relevant emoji on the first line,
which is max 72 characters and cannot end with a punctuation mark.
Leave a blank line after the first line.
Then add the rest of the commit message explaining the changes.
The other lines cannot be longer than 120 characters.
The commit message can contain Markdown formatting.
The tone of the commit message should be sassy and friendly.
IMPORTANT: Only output the final commit message. Do NOT include any explanations or internal reasoning.
`.trim();

/**
 * Generate the prompt message body for OpenRouter API.
 */
function buildRequestBody(promptMessage, diff, model) {
  const fullPrompt = `${promptMessage}\n\n${INSTRUCTIONS}`;

  return {
    model,
    messages: [
      {
        role: "user",
        content: `${fullPrompt}\n\n${diff}`,
      },
    ],
    temperature: 0.7,
  };
}

/**
 * Call the OpenRouter API with retry logic for transient errors.
 */
async function fetchCommitMessageWithRetry(
  body,
  token,
  retries = 5,
  delay = 1000,
) {
  for (let attempt = 1; attempt <= retries; attempt++) {
    try {
      const response = await fetch(URL, {
        method: "POST",
        headers: {
          Authorization: `Bearer ${token}`,
          "Content-Type": "application/json",
          "HTTP-Referer": `https://github.com/${process.env.GITHUB_REPOSITORY}`,
          "X-Title": "AI Commit Message",
        },
        body: JSON.stringify(body),
      });

      if (response.ok) {
        const json = await response.json();
        return json.choices?.[0]?.message?.content || "";
      }

      if (
        [HTTP_TOO_MANY_REQUESTS, HTTP_SERVICE_UNAVAILABLE].includes(
          response.status,
        )
      ) {
        const backoff = delay * Math.pow(2, attempt - 1);
        core.warning(
          `Attempt ${attempt} failed with ${response.status} ${response.statusText}, retrying in ${backoff}ms...`,
        );
        await new Promise((res) => setTimeout(res, backoff));
      } else {
        const text = await response.text();
        throw new Error(
          `OpenRouter API error: ${response.status} ${response.statusText} ‚Äî ${text}`,
        );
      }
    } catch (error) {
      if (attempt === retries) {
        throw new Error(
          `OpenRouter API error after ${retries} attempts: ${error.message}`,
        );
      }
      await new Promise((res) =>
        setTimeout(res, delay * Math.pow(2, attempt - 1)),
      );
    }
  }
}

/**
 * Clean and truncate the commit message.
 */
function sanitizeMessage(message) {
  const cleaned = message.replace(/`/g, "");
  const lines = cleaned.split("\n");
  if (lines.length > 0) {
    lines[0] = lines[0].slice(0, 72);
  }
  return lines.join("\n");
}

/**
 * Try fetching commit message with a specified model.
 */
async function tryFetchWithModel(promptMessage, diffContent, token, model) {
  const body = buildRequestBody(promptMessage, diffContent, model);
  return await fetchCommitMessageWithRetry(body, token);
}

/**
 * Output the commit message to console and set the action output.
 */
function outputMessage(modelName, message) {
  const finalMessage = sanitizeMessage(message);
  core.info(
    `ü§ñ Using commit message from model "${modelName}":\n${finalMessage}`,
  );
  core.setOutput("message", finalMessage);
}

/**
 * Main entrypoint for the action.
 */
async function run() {
  const diffContent = core.getInput("diff_content");
  const promptMessage = core.getInput("prompt_content");
  const token = process.env.OPENROUTER_API_KEY;

  if (!token) {
    core.setFailed("‚ùå OPENROUTER_API_KEY is not set");
    return;
  }

  if (!diffContent) {
    core.setFailed("‚ùå diff_content input is empty");
    return;
  }

  let lastError = null;
  for (const model of MODELS) {
    try {
      const message = await tryFetchWithModel(
        promptMessage,
        diffContent,
        token,
        model,
      );
      if (!message) throw new Error(`No message generated by model ${model}`);
      outputMessage(model, message);
      return; // success, exit early
    } catch (error) {
      core.warning(`Model ${model} failed: ${error.message}`);
      lastError = error;
    }
  }

  core.setFailed(
    `All models failed. Last error: ${lastError?.message || "unknown error"}`,
  );
}

run();
